# 容器

**容器** 是一种虚拟化技术，它将应用程序及其所有依赖项打包在一起，在一个独立的环境中运行。
容器由容器引擎（如 Docker）管理，具有以下特点：

- 独立性：容器与主机隔离，拥有自己的文件系统、网络和运行环境。
- 可移植性：容器可以在任何支持容器技术的系统上运行，确保一致性。
- 灵活性：容器支持运行不同版本的软件或复杂的多服务架构。

**容器的常见用途**：

- 在开发、测试和生产环境之间提供一致的运行环境。
- 隔离不同服务，避免冲突。

## Docker

- 是一个 **容器化平台**，主要用于创建、运行和管理容器。

- 容器是轻量级、独立的运行环境，包含应用及其所需的所有依赖（如库、配置文件等）。

- Docker 的目标是确保应用在任何环境下（开发、测试、生产）运行一致。

**优势**：

- 轻量化部署：相比于VM，Docker容器更小，启动速度更快。
- 移植性：在不同环境中保持一致性。
- 便于维护：更新或修改无需重新安装整个环境。
- 高效资源利用：容器共享核心，降低资源消耗。

**Docker上的image是否能在外部使用**：

- Docker中下载的任何image（如MySQL）不能直接在容器外部使用。
- 如果需要在容器外使用MySQL，需要单独安装MySQL服务器。
- Docker容器和容器外的服务是相互独立的，同时安装两份实例也比较常见。

### **1. 安装方式**

- **Docker**:

  - 通过下载容器镜像运行应用。

  - 容器镜像是自包含的，包含了应用程序及其依赖的所有环境。

  - 例如，运行 MySQL 5.7：

    ```
    bash
    
    
    复制代码
    docker pull mysql:5.7
    docker run --name mysql57 -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 -d mysql:5.7
    ```

------

### **2. 隔离性**

- **Docker**:
  - 高度隔离：每个容器有自己的文件系统、网络栈和运行环境。
  - 可以在同一主机上运行不同版本的软件而不会冲突。例如，你可以同时运行 MySQL 5.7 和 8.0 的容器。
  - 不依赖主机的系统环境，适合测试或需要运行特定环境的软件。

------

### **3. 使用场景**

- **Docker**:
  - 适合需要运行复杂环境的应用（比如带有多个依赖的服务）。
  - 用于隔离环境、快速部署或运行特定版本的软件。
  - 多用于开发、测试、生产环境的发布和部署。
  - 举例：需要运行一个旧版本的 PHP 环境进行测试，但不想影响主机的 PHP 版本。

------

### **4. 性能**

- **Docker**:
  - 容器运行在主机的虚拟化环境中，启动速度比虚拟机快，但资源隔离导致略有性能开销。
  - 适合需要频繁启动和停止的应用，但可能会比直接运行稍慢。

------

### **5. 管理方式**

- **Docker**:

  - 使用命令行工具管理容器和镜像。

  - 可随时删除容器，确保主机环境保持干净。

  - 示例命令：

    ```
    bash
    
    
    复制代码
    docker ps        # 查看运行中的容器
    docker stop ID   # 停止容器
    docker rm ID     # 删除容器
    ```


###  6.数据持久化

**Docker中是否持久化数据**：

- Docker本身运行的实例没有持久化机制，如果不做数据持久化，重启容器时数据会丢失。
- **三种持久化方式**：
  1. **Bind Mount指定文件夹：**容器和宿主机共享相同的目录。
  2. **Docker Volume：**由Docker系统管理的相关目录。
  3. **NFS或其他资源：**适合应用有多节点平台。

**推荐：**

- 通过Docker Volume进行数据持久化，更便管理和跨实例共享。

### 7.容器和容器文件的管理

**容器和容器文件管理**：

- Docker中一个image可以运行多个实例，每个实例是独立的环境，包括存储和数据。
- **多实例是否出现端口冲突**：
  - 如果运行两个实例，且均使用 `-p 3306:3306`，则会出现端口冲突。
  - 解决方案：为每个实例指定不同的宿主机端口（例如：3306和3307）。

**示例**：

``` bash
docker run -d -e MYSQL_ROOT_PASSWORD=fb0789sy -p 3306:3306 mysql:5.7   # 第一个实例
docker run -d -e MYSQL_ROOT_PASSWORD=fb0789sy -p 3307:3306 mysql:5.7   # 第二个实例
```

### 8.**Docker Compose 概念和优势**

- Docker Compose是一个用于实现多容器并行部署和管理的工具。
- **优势**：
  - 简化操作：用一个`docker-compose.yml`文件描述所有容器。
  - 便于重复：可以进行快速的重复部署。
  - 多实例维护更方便。

**用法**：

1. 创建 `docker-compose.yml`：

```yaml
version: '3.8'
services:
  db:
    image: mysql:5.7
    container_name: mysql_container
    ports:
      - "3306:3306"
    environment:
      MYSQL_ROOT_PASSWORD: fb0789sy
    volumes:
      - db_data:/var/lib/mysql
volumes:
  db_data:
```

1. 运行 Compose：

```bash
docker-compose up -d
```

1. 查看状态：

```bash
docker-compose ps
```

**推荐：如果有多容器核心服务，使用 Docker Compose 管理更便捷。**

### 9.**实际场景：何时使用Docker，何时使用宿主机部署**

- **Docker适合**：
  - Redis、RabbitMQ、Nginx：这类资源阅读性较高，对性能效果作用不大。
  - 用于开发和测试环境。
- **宿主机适合**：
  - MySQL：高带容量或高性能场景，需要降低实现层。
  - ElasticSearch：大

#### 适合 Docker 部署的场景

1. **开发与测试环境：**
   - 快速创建和销毁环境，便于测试不同版本的服务或应用。
   - 提供一致的运行环境，避免“开发能跑，生产不能跑”的问题。
2. **微服务架构：**
   - 每个服务独立运行，易于扩展和管理。
   - 服务隔离，避免依赖冲突。
3. **频繁迭代或分布式系统：**
   - 容易发布新版本和回滚。
   - 适合快速部署和动态扩展。
4. **跨平台兼容性：**
   - 使用容器镜像，保证在不同平台（如 macOS、Linux、Windows）上的一致性。
5. **资源隔离与利用率：**
   - 通过容器限制资源使用（CPU、内存等），提高资源利用率。
   - 减少服务之间的相互干扰。
6. **持续集成与持续部署（CI/CD）：**
   - 容器化的应用方便集成到自动化流水线中。
7. **依赖复杂且多样的服务：**
   - 例如需要运行 MySQL、Redis、RabbitMQ 等多种服务，Docker Compose 可以方便管理。

#### 适合宿主机部署的场景

1. **高性能需求：**
   - 数据库如 MySQL、PostgreSQL 在高并发、高性能的场景下，直接部署在宿主机上更高效。
   - 数据库的文件系统和网络性能在容器中可能稍逊，宿主机更能直接发挥硬件性能。
2. **单一服务，长期运行：**
   - 如果某服务长期稳定运行，不需要频繁更改，直接部署在宿主机上可以减少容器管理的复杂性。
3. **高可靠性需求：**
   - 容器可能因管理不当、镜像更新等引发额外的风险，关键任务服务更适合宿主机运行。
4. **需要直接访问硬件的应用：**
   - 如 GPU 加速或特殊硬件要求的应用。
   - 直接部署可以更高效利用硬件。
5. **不需要复杂依赖管理的简单服务：**
   - 单一静态网站或不涉及多种依赖的简单服务，直接在宿主机运行更轻量。

#### 综合建议

- **混合部署：**
  - 对于高性能需求的核心服务（如数据库、缓存），建议使用宿主机直接部署。
  - 对于边缘服务（如微服务组件、代理、消息队列），建议使用 Docker 管理。
- **视团队能力和项目规模选择：**
  - 如果团队熟悉 Docker 和容器管理，可更多采用容器化。
  - 如果团队对容器不熟悉，避免全部使用 Docker，可能引入不必要的复杂性。
- **根据实际需求灵活选择：**
  - 评估服务的特性和需求，选择最合适的方式，不必完全依赖某一种工具或方法。



### 总结

容器技术通过创建独立的虚拟环境，来确保应用和服务的运行不受宿主操作系统或其他应用的干扰，从而实现环境隔离和管理的灵活性。

#### 关于docker和wsl：

1. **Docker**：
   - **Docker** 本身就创建了一个虚拟空间（这个虚拟空间可以理解为 Docker 引擎本身运行的 Linux 环境），在这个环境中，你可以启动多个 **容器**。每个容器都像一个独立的小虚拟机，拥有自己的文件系统、进程和网络，但它们共享宿主机的内核（在 Linux 系统上是宿主机的 Linux 内核，在 Windows 系统上通过 WSL 提供的 Linux 内核）。
   - 这样，容器就能够提供环境隔离，每个容器中的应用都不受宿主系统或其他容器的影响，确保了应用的稳定性和可移植性。
2. **WSL**：
   - **WSL**（Windows Subsystem for Linux）本质上是 Windows 上的一个虚拟环境，提供了一个模拟的 Linux 内核，允许你在 Windows 系统中运行 Linux 二进制文件。
   - 在 WSL 中，你可以安装并管理 SDK、开发工具等，保持了 Linux 环境的纯净性，不会直接影响到 Windows 系统的运行。
   - 和 Docker 不同，WSL 本质上是一个 **单一虚拟环境**，你可以把它当作一个虚拟机来使用，而 Docker 是为每个容器提供 **隔离的虚拟环境**，并且可以在同一宿主机上同时运行多个容器。

#### **容器的意义和价值**：

- **环境隔离**：每个容器内的应用环境都是独立的，彼此之间互不影响。这使得你可以在不同的容器中运行不同版本的应用或不同的服务，避免了依赖冲突。
- **移植性**：容器内的应用和环境可以轻松地从开发环境迁移到测试、生产环境，确保各环境的一致性。
- **高效资源利用**：容器相对于虚拟机来说，开销较小，因为它们共享宿主机的内核资源，而不需要单独运行一个完整的操作系统。
- **灵活性和可扩展性**：容器化的应用可以轻松扩展，容器可以根据需要快速启动和销毁，非常适合现代云计算和微服务架构。

#### **容器的文件系统和存储**：

1. **共享宿主机内核**：
   - Docker 容器 **共享宿主机的 Linux 内核**，所以它们都依赖于宿主机的内核来运行。但容器之间是相互独立的，它们运行的应用和环境是 **隔离的**。
2. **文件系统隔离**：
   - 每个容器有 **独立的文件系统**，这意味着每个容器内的文件、配置和应用运行环境都是隔离的。
   - 这些文件系统是通过 Docker 提供的 **联合文件系统（UnionFS）** 实现的。例如，Docker 使用 `aufs` 或 `overlay2` 等文件系统技术来创建容器的文件系统层。每个容器都会拥有自己的文件系统视图，但底层它们共享宿主机的文件系统资源。
3. **镜像和容器的关系**：
   - Docker 容器是由 **镜像** 启动的，镜像是包含操作系统、库、依赖、应用等的只读文件系统。
   - 每个容器都会创建一个 **写时复制（Copy-on-Write）** 的层，这意味着容器的文件系统最初是只读的，但当容器进行修改时，这些修改会记录在容器自己的写层中。其他容器并不会受到影响。
4. **网络隔离**：
   - 容器有 **独立的网络空间**，每个容器都有自己的虚拟网络接口，容器之间的通信通常通过 **Docker 网络桥接** 或其他网络模式来进行，确保网络隔离。
   - 每个容器都可以拥有独立的 IP 地址和端口映射，但默认情况下，它们无法直接访问宿主机或其他容器的网络，除非显式地配置。

#### **容器和硬盘的对比**：

- 你可以将容器比作 **虚拟硬盘**，但是它们并不是物理硬盘，而是 **虚拟化的文件系统**，这个文件系统并不会占用物理硬盘的整个空间，而是动态使用存储资源。容器是通过分配 **存储卷（Volumes）** 来持久化数据，或者容器的文件系统会在容器销毁后被清空。
- 每个容器内的文件系统是由镜像层和写时复制层组成，它并不需要专门的物理硬盘来存储。容器的隔离更多体现在 **文件系统的视图** 和 **数据存储位置** 上，而不是物理硬件层面。

#### **总结**：

- 每个容器是独立的，隔离的环境，它们共享宿主机的内核，但有自己的文件系统、进程空间和网络。
- 容器的文件系统采用 **写时复制（Copy-on-Write）** 机制，容器修改的数据不会影响其他容器。
- 容器并不像物理硬盘那样拥有独立的硬盘，而是通过 **共享宿主机资源** 来创建独立的存储空间和隔离环境。

## 文件系统视图

“**文件系统视图**”是一个在容器技术中非常重要的概念，特别是在 **Docker** 中，它帮助我们理解容器和宿主机之间的文件系统隔离。

### **文件系统视图的定义**：

简单来说，**文件系统视图** 是容器内对其文件系统的 **抽象视图**。它是容器可以看到和访问的文件系统的“视图”，但这个视图并不等于宿主机的物理文件系统，而是容器操作系统内部定义的视图。

### **理解文件系统视图**：

1. **镜像层（Read-Only Layer）**：
   - Docker 镜像本身是一个 **只读的文件系统层**，这个镜像文件系统包含了操作系统、库、依赖和应用程序等内容。当你启动一个容器时，容器的文件系统 **从镜像层创建**，但是它是只读的。
2. **容器层（Read-Write Layer）**：
   - 每个容器在运行时会创建一个自己的 **写时复制（Copy-on-Write）** 层，所有对文件系统的 **修改**（例如新增文件、修改文件、删除文件等）都会记录在这个层中。这个层是容器的 **读写层**，它是动态的，可以随容器的运行而变化。
3. **联合文件系统（UnionFS）**：
   - Docker 使用 **联合文件系统（UnionFS）** 将多个层（镜像层和容器层）结合在一起。这种方式让容器看起来有一个完整的文件系统视图，实际上它是多个层叠加形成的。
4. **容器的文件系统视图**：
   - 当你在容器内执行命令时，看到的文件系统就是这些层的合并视图：
     - 你可以读到镜像层中的文件，因为它们是只读的。
     - 如果容器修改了某个文件，修改会只影响容器自己的写层。
     - **其他容器**则不会看到这些修改，除非它们共享某些卷（volumes）或者共享目录。

### **文件系统视图的工作机制**：

- **只读镜像层**：每个容器基于镜像启动时，镜像文件系统是只读的。镜像文件系统通常包含了操作系统的基础部分和一些已经安装的依赖、应用等。
- **写时复制（Copy-on-Write）**：当容器运行时，Docker 会为容器提供一个写时复制的层，这个层会记录容器对文件系统的修改。例如，如果容器修改了某个文件，这个修改会记录在写层，而不会直接修改镜像层。
- **联合文件系统**：Docker 通过联合文件系统将镜像层和容器的写层合并起来，提供给容器一个 **完整的文件系统视图**，容器内看到的文件系统是由多个层合成的虚拟文件系统。

### **文件系统视图的隔离性**：

- **文件系统隔离**：容器的文件系统视图和宿主机的文件系统是 **隔离的**，这意味着容器内部的文件更改不会影响宿主机的文件系统，除非显式地将某些目录挂载到宿主机上（比如 Docker 卷）。
- **容器间的隔离**：不同容器之间也是隔离的，它们各自拥有独立的文件系统视图，互相不能看到对方的文件系统，除非它们通过共享卷来互通数据。

### **总结**：

“文件系统视图”是容器内对其文件系统的一个抽象，它由多个层次（镜像层和容器层）组成。镜像层是只读的，容器在运行时会创建一个可写的层，所有对文件系统的修改都会记录在这个写层中。通过联合文件系统，容器可以看到一个完整的文件系统视图，这个视图是由多个层叠加形成的，保证了容器的独立性和隔离性。

你可以把文件系统视图想象成容器“看见的”文件系统，它不是物理的硬盘存储，而是虚拟的、分层的文件系统结构。这样可以让容器在共享宿主机内核的同时，保持隔离和高效性。

## Docker 操作相关



### 关于启动

#### **1. 如果还没有创建 MySQL 容器**

你需要使用 `docker run` 命令来创建并启动容器。例如：

```bash
docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=yourpassword -d mysql:5.7
```

**解释：**

- `--name mysql`：指定容器的名称为 `mysql`。
- `-p 3306:3306`：将宿主机的 3306 端口映射到容器的 3306 端口（MySQL 默认端口）。
- `-e MYSQL_ROOT_PASSWORD=yourpassword`：设置 MySQL root 用户的密码。
- `-d mysql:5.7`：使用 `mysql:5.7` 镜像，并以守护模式（后台运行）启动。

运行后，可以通过以下命令检查容器状态：

```bash
docker ps -a
```

#### **2. 如果容器已经存在但被停止**

这时可以使用 `docker start` 命令直接启动该容器：

```bash
docker start mysql
```

**前提：**

- 容器之前已经通过 `docker run` 创建过。
- 容器名为 `mysql`（或使用容器 ID）。

**总结**

- **首次启动镜像并创建容器**：`docker run`。
- **重启已停止的容器**：`docker start`。 

#### **启动 MySQL 容器时指定密码**

使用以下命令重新启动容器，并设置 root 用户密码：

```bash
docker run --name mysql \
-e MYSQL_ROOT_PASSWORD=yourpassword \
-p 3306:3306 \
-d mysql:5.7
```

参数说明：

- `--name mysql`：设置容器的名字为 `mysql`。
- `-e MYSQL_ROOT_PASSWORD=yourpassword`：设置 root 用户密码（请替换 `yourpassword`）。
- `-p 3306:3306`：将主机的 3306 端口映射到容器的 3306 端口。
- `-d`：后台运行容器。



### 如果启动失败

#### 1. **MySQL 容器启动失败**

从你的 `docker ps -a` 输出可以看到，容器 `relaxed_golick` 状态为 `Exited (1)`，这说明容器在启动时发生了错误。

**排查 MySQL 容器启动失败的原因**

可以通过以下命令查看具体错误日志：

```bash
docker logs d6787bb7ae52
```

根据日志信息，常见的问题可能包括：

- 未设置 `MYSQL_ROOT_PASSWORD`

  ： 如果你启动容器时没有指定 root 用户的密码，MySQL 可能无法正常初始化。确保用以下命令启动：

  ```bash
  docker run --name mysql -e MYSQL_ROOT_PASSWORD=yourpassword -p 3306:3306 -d mysql:5.7
  ```

- 端口冲突

  ： 如果主机的 3306 端口已经被占用，MySQL 容器也会启动失败。可以尝试更换端口：

  ```bash
  docker run --name mysql -e MYSQL_ROOT_PASSWORD=yourpassword -p 3307:3306 -d mysql:5.7
  ```

- **数据目录权限问题**： 如果你挂载了本地数据目录，但权限不足，MySQL 也无法启动。这时需要修复权限或移除挂载。

**解决容器问题的步骤**

1. 删除之前的失败容器：

   ```bash
   docker rm d6787bb7ae52
   ```

2. 使用正确命令重新启动：

   ```bash
   docker run --name mysql -e MYSQL_ROOT_PASSWORD=yourpassword -p 3306:3306 -d mysql:5.7
   ```

#### 2. **本地 MySQL 客户端未安装**

从你尝试运行 `mysql --version` 的结果来看，当前系统中未安装 MySQL 客户端，因此无法使用 `mysql` 命令来连接数据库。

**如何安装 MySQL 客户端**

你可以根据操作系统安装 MySQL 客户端工具：

- **Windows：**

  1. 下载 MySQL 官方安装包：[MySQL Installer](https://dev.mysql.com/downloads/installer/)
  2. 在安装向导中选择 **MySQL Client** 组件。
  3. 安装完成后，将 MySQL 客户端路径（如 `C:\Program Files\MySQL\MySQL Server 8.0\bin`）添加到系统的环境变量中。

- **使用包管理工具（Homebrew on Windows 或 Linux/Mac）** 如果你有 Homebrew：

  ```bash
  brew install mysql-client
  ```

#### 3. **如何从本地连接 Docker 中的 MySQL**

当你的 MySQL 容器正常启动后，可以通过本地 MySQL 客户端连接：

```bash
mysql -h 127.0.0.1 -P 3306 -u root -p
```

- `-h 127.0.0.1`：指定主机地址（Docker 默认监听本地地址）。
- `-P 3306`：指定端口号（与容器映射端口一致）。
- `-u root`：使用 root 用户。
- `-p`：提示输入密码。

输入 `MYSQL_ROOT_PASSWORD` 时设置的密码即可登录。

#### 总结

1. 你的容器启动失败，需通过 `docker logs` 检查具体原因并修复后重新运行。
2. `mysql --version` 报错是因为本地未安装 MySQL 客户端，需安装后使用。
3. 修复后，可通过本地客户端使用 `mysql` 命令连接 Docker 中的 MySQL 服务。



### 运行并使用Docker中的MySQL

如果你不想在本地安装 MySQL 客户端，可以直接进入运行 MySQL 的 Docker 容器，并在容器内使用 `mysql` 命令。

- 进入容器：

  ```bash
  docker exec -it mysql bash
  ```

- 在容器内使用 `mysql` 命令连接 MySQL：

  ```bash
  mysql -u root -p
  ```

  然后输入 MySQL 的 root 用户密码。